````markdown
### 引用 vs 智能指针

引用和智能指针都允许您间接访问数据，但它们在所有权、内存管理和用例方面有重要区别。

### 引用 (&T, &mut T)

引用是 Rust 中最基本的间接形式。它们借用数据而不获取所有权。

**特点**:
- 零运行时成本（只是指针）
- 不拥有它们指向的数据
- 必须在编译时遵循 Rust 的借用规则
- 不能比它们引用的数据活得更长
- 不涉及堆分配

```rust, editable
fn main() {
    let x = 5;
    let y = &x;  // 不可变引用
    println!("x: {}, y: {}", x, y);
    
    let mut z = 10;
    let w = &mut z;  // 可变引用
    *w += 5;
    println!("z: {}", z);
}
```

### 智能指针 (Box, Rc, Arc, 等)

智能指针是行为类似于指针但具有附加元数据和功能的数据结构。它们拥有它们指向的数据。

**特点**:
- 拥有它们指向的数据
- 当它们离开作用域时自动清理 (RAII)
- 可能涉及堆分配
- 可能有运行时开销（引用计数、原子操作）
- 启用仅用引用无法实现的模式

```rust, editable
use std::rc::Rc;

fn main() {
    // Box: 单一所有权，堆分配
    let b = Box::new(5);
    println!("Box: {}", b);
    
    // Rc: 共享所有权 (单线程)
    let rc1 = Rc::new(10);
    let rc2 = Rc::clone(&rc1);
    println!("Rc: {}, {}", rc1, rc2);
}
```

### 主要区别

| 特性 | 引用 | 智能指针 |
|---------|-----------|----------------|
| **所有权** | 仅借用 | 拥有数据 |
| **生命周期** | 与借用的数据绑定 | 独立 |
| **堆分配** | 否 | 通常是 |
| **运行时成本** | 零 | 可能有开销 |
| **共享** | 受借用规则限制 | Rc/Arc 允许共享 |
| **何时使用** | 最常见的情况 | 递归类型、共享所有权、堆分配 |

### 何时使用

**使用引用当**:
- 您只需要临时读取或修改数据
- 数据所有者清晰且生命周期明显
- 性能至关重要（零成本抽象）

**使用智能指针当**:
- 您需要堆分配 (`Box`)
- 您需要共享所有权 (`Rc` 用于单线程, `Arc` 用于多线程)
- 您有递归数据结构 (`Box`)
- 您需要内部可变性与共享所有权 (`Rc<RefCell<T>>`)
````
